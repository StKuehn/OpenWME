/*
Copyright (c) 2023 by Steffen KÃ¼hn, steffen.kuehn@aurinovo.de

This file is part of OpenWME, an electromagnetic field solver based on
Weber-Maxwell electrodynamics.

OpenWME is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later version.

OpenWME is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <https://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <math.h>
#include "constants.h"
#include "scene.h"
#include "display.h"

const TVector black = TVector(0.25, 0.25, 0.25);
const TVector blue = TVector(0, 0, 1);
// the time step of the simulation
const sim_double dt = 10 * us;
const sim_double amp = 10 * cm;
const sim_double freq = 1 * kHz;
// current strength
const sim_double current = 10 * A;
// number of current elements
const int segments = 500;
// radius of the current loop
const sim_double radius = 20 * cm;
// charge per segment
const sim_double charge = current * dt;
// angular speed of the current
const sim_double angvel = (2 * pi * current) / (charge * segments);

TVector PositionFunc(sim_double t, TVector r0, sim_double av)
{
	TVector r(r0.x * cos(av * t) - r0.z * sin(av * t), 0, r0.z * cos(av * t) + r0.x * sin(av * t));
	return r + TVector(0, 0, amp * sin(2 * freq * pi * t));
}

TVector VelocityFunc(sim_double t, TVector r0, sim_double av)
{
	TVector v(-(av * r0.z * cos(av * t)) - av * r0.x * sin(av * t), 0, av * r0.x * cos(av * t) - av * r0.z * sin(av * t));
	return v + TVector(0, 0, 2 * amp * freq * pi * cos(2 * freq * pi * t));
}

TVector AccelerationFunc(sim_double t, TVector r0, sim_double av)
{
	TVector a(-(av * av * r0.x * cos(av * t)) + av * av * r0.z * sin(av * t), 0, -(av * av * r0.z * cos(av * t)) - av * av * r0.x * sin(av * t));
	return a + TVector(0, 0, -4 * amp * freq * freq * pi * pi * sin(2 * freq * pi * t));
}

TVector PositionFuncP(sim_double t, TVector r0)
{
	return PositionFunc(t, r0, -angvel / 2);
}

TVector VelocityFuncP(sim_double t, TVector r0)
{
	return VelocityFunc(t, r0, -angvel / 2);
}

TVector AccelerationFuncP(sim_double t, TVector r0)
{
	return AccelerationFunc(t, r0, -angvel / 2);
}

TVector PositionFuncN(sim_double t, TVector r0)
{
	return PositionFunc(t, r0, angvel / 2);
}

TVector VelocityFuncN(sim_double t, TVector r0)
{
	return VelocityFunc(t, r0, angvel / 2);
}

TVector AccelerationFuncN(sim_double t, TVector r0)
{
	return AccelerationFunc(t, r0, angvel / 2);
}

int main()
{
	TScene scene;
	// container for the particles that form the current loop
	std::deque<TParticle*> DCCurrentLoop;
	// a field with virtual test charges to represent the forces as a function of location
	std::deque<TParticle*> Field;

	// create the current loop
	for (int i = 0; i < segments; i++)
	{
		TVector r(radius * sin(2 * pi / segments * i), 0, radius * cos(2 * pi / segments * i));

		TParticle* Ions = scene.Add_Particle();
		Ions->ToPointCharge(1, charge);
		Ions->SetFixedTrajectory(r, PositionFuncP, VelocityFuncP, AccelerationFuncP);
		DCCurrentLoop.push_back(Ions);

		TParticle* Electrons = scene.Add_Particle();
		Electrons->ToPointCharge(1, -charge);
		Electrons->SetFixedTrajectory(r, PositionFuncN, VelocityFuncN, AccelerationFuncN);
		DCCurrentLoop.push_back(Electrons);
	}

	// create a grid of test charges to represent the field generated by the Hertzian dipole
	for (int ix = -10; ix <= 10; ix++)
	{
		for (int iz = -10; iz <= 10; iz++)
		{
			// a probe is a virtual point charge that can receive forces but does not generate
			// forces itself. Such objects do not exist in reality. They serve only for
			// visualization. Note that a probe can also have an instantaneous velocity and that
			// the perception of the field depends on it.
			TParticle* probe = scene.Add_Probe(TVector(ix * 5 * cm, 0, iz * 5 * cm), TVector(0, 0, 0));
			Field.push_back(probe);
		}
	}

	// define an electromagnetic force between each probe and the current loop
	for (std::size_t i = 0; i < DCCurrentLoop.size(); i++)
	{
		for (std::size_t j = 0; j < Field.size(); j++)
		{
			scene.Add_WeberMaxwellForce(DCCurrentLoop[i], Field[j]);
		}
	}

	// open a window to display the the setup
	TDisplay display(700, 700, -50 * cm, -50 * cm, 50 * cm, 50 * cm, "Moving current loop with DC current");

	for (int i = 0; ; i++)
	{
		// time step
		scene.TimeStep(dt);

		// display simulation
		display.Clear();

		display.PlotForceFieldXZ(Field, i * dt, 1e3, 10, 10, black);

		// show current loop with current direction
		for (std::size_t j = 0; j < DCCurrentLoop.size(); j++)
		{
			display.DrawParticle(DCCurrentLoop[j], i * dt, 5, blue);
		}

		display.DrawTime(i * dt / us, "us", 1, black);

		display.Draw(true);
	}

	return 0;
}
