/*
Copyright (c) 2023 by Steffen KÃ¼hn, steffen.kuehn@aurinovo.de

This file is part of OpenWME, an electromagnetic field solver based on
Weber-Maxwell electrodynamics.

OpenWME is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later version.

OpenWME is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <https://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <math.h>
#include "constants.h"
#include "scene.h"
#include "display.h"

const TVector black = TVector(0.25, 0.25, 0.25);
const TVector red = TVector(1, 0, 0);
const TVector blue = TVector(0, 0, 1);
const sim_double dt = 0.1 * ns;

const sim_double maxtime = 50 * ns;
const sim_double charge = -1e14 * e;
const sim_double mass = 1 * g;
// duration of the acceleration phase
const sim_double dur = 30 * ns;
// final speed
const sim_double vmax = 0.9999 * c;
// position after completion of the acceleration phase
const sim_double x1 = 0 * m;
// position at the beginning of the acceleration phase
const sim_double x0 = x1 - (dur*vmax * (8.0 + log(cosh(4)))) / 16.0;

const sim_double reflpara = 2e4;
const sim_double refldelay = 0;

// trajectory
TVector trajectory0(sim_double t, TVector r0)
{
	return TVector((t * vmax) / 2.0 + x0 + (dur * vmax * log(cosh(4.0 - (8.0 * t) / dur))) / 16.0, 0, 0);
}

// first derivative of the trajectory with respect to time
TVector trajectory1(sim_double t, TVector r0)
{
	return TVector(vmax / 2.0 - (vmax * tanh(4 - (8 * t) / dur)) / 2., 0, 0);
}

// second derivative of the trajectory with respect to time
TVector trajectory2(sim_double t, TVector r0)
{
	return TVector((4 * vmax * pow(1.0 / cosh(4 - (8 * t) / dur), 2)) / dur, 0, 0);
}

int main()
{
	TScene scene;
	std::deque<TParticle*> Field;

	// create the point charge (electron burst)
	TParticle* Electron = scene.Add_Particle();
	Electron->ToPointCharge(mass, charge);
	Electron->SetFixedTrajectory(TVector(0, 0, 0), trajectory0, trajectory1, trajectory2);

	// create the pipe
	std::deque<TParticle*> Pipe;
	for (int iz = -1; iz <= 1; iz += 2)
	{
		for (int ix = -300; ix <= 0; ix++)
		{
			TParticle* Reflector = scene.Add_Particle();
			Reflector->ToHertzianDipole(1, 1, 0, 0, 0, TVector(0, 0, 1), NULL);
			Reflector->MakeReflective(reflpara, refldelay, 1000);
			Reflector->SetLinearTrajectory(TVector(ix * 2 * cm, 0, iz * 20 * cm), TVector(0, 0, 0));
			Pipe.push_back(Reflector);
		}
	}

	// create electromagnetic forces between electron and pipe
	for (std::size_t j = 0; j < Pipe.size(); j++)
	{
		scene.Add_WeberMaxwellForce(Pipe[j], Electron);
	}

	// create a grid of test charges to represent the field generated by the point charge
	for (int ix = -50; ix <= 50; ix++)
	{
		for (int iz = -20; iz <= 20; iz++)
		{
			TParticle* Probe = scene.Add_Probe(TVector(ix * 10 * cm, 0, iz * 10 * cm), TVector(0, 0, 0));
			Field.push_back(Probe);
			scene.Add_WeberMaxwellForce(Electron, Probe);
			for (std::size_t j = 0; j < Pipe.size(); j++)
			{
				scene.Add_WeberMaxwellForce(Pipe[j], Probe);
			}
		}
	}

	// open a window to display the field and motion of the particle
	TDisplay display(1000, 400, -5 * m, -2 * m, 5 * m, 2 * m, "Pizzella's experiment");

	// simulate the field step by step
	for (int i = 0; i * dt <= maxtime; i++)
	{
		// time step
		scene.TimeStep(dt);

		// display simulation
		display.Clear();
		display.PlotForceFieldXZ(Field, i * dt, 1e-5, 10, 10, black);
		display.DrawTime(i * dt / ns, "ns", 1, red);
		display.DrawParticle(Electron, i * dt, 5, red);
		for (std::size_t j = 0; j < Pipe.size(); j++)
		{
			display.DrawParticle(Pipe[j], i * dt, 7, blue);
		}
		display.Draw(true);
	}

	return 0;
}
