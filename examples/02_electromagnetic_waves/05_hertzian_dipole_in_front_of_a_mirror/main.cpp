/*
Copyright (c) 2023 by Steffen KÃ¼hn, steffen.kuehn@aurinovo.de

This file is part of OpenWME, an electromagnetic field solver based on
Weber-Maxwell electrodynamics.

OpenWME is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later version.

OpenWME is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <https://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <math.h>
#include "constants.h"
#include "scene.h"
#include "display.h"

const TVector black = TVector(0.25, 0.25, 0.25);
const TVector green = TVector(0, 1, 0);
const TVector red = TVector(1, 0, 0);
const TVector blue = TVector(0, 0, 1);

const sim_double dt = 0.5 * ns;
const sim_double freq = 100 * MHz;
const sim_double amp = 1 * nm;
const sim_double charge = 1e14 * e;
const sim_double reflpara = 1e6;
const sim_double mass = 1 * g;
const sim_double maxtime = 100 * ns;

sim_double AmplModFunc(sim_double t)
{
	if (t < 0) return 0;
	return 1;
}

int main()
{
	std::deque<TVector> directions = {TVector(0, 0, 1), TVector(1 / sqrt(2.0), 0, 1 / sqrt(2.0)), TVector(1, 0, 0)};
	// open a window to display the field and motion of the Hertzian dipole
	TDisplay display(600, 300, -20 * m, -5 * m, 0 * m, 5 * m, "Hertzian dipole in front of a mirror");

	for (std::size_t id = 0; id < directions.size(); id++)
	{
		TScene scene;
		// two fields with virtual test charges to represent the forces as a function of location
		std::deque<TParticle*> PrimaryField;
		std::deque<TParticle*> SecondaryField;

		// create the transmitter
		TParticle* Transmitter = scene.Add_Particle();
		// convert the point charge into a Hertzian dipole
		Transmitter->ToHertzianDipole(mass, charge, amp, freq, 0, directions[id], AmplModFunc);
		// set position
		Transmitter->SetLinearTrajectory(TVector(-10 * m, 0, 0), TVector(0, 0, 0));

		// create a grid of test charges to represent the field generated by the transmitter
		for (int ix = -40; ix <= 0; ix++)
		{
			for (int iz = -10; iz <= 10; iz++)
			{
				TParticle* Probe = scene.Add_Probe(TVector(ix * 0.5 * m, 0, iz * 0.5 * m), TVector(0, 0, 0));
				PrimaryField.push_back(Probe);
				scene.Add_WeberMaxwellForce(Transmitter, Probe);
			}
		}

		// the mirror
		std::deque<TParticle*> Mirror;
		for (int iz = -20; iz <= 20; iz++)
		{
			TParticle* Reflector = scene.Add_Particle();
			// convert the point charge into a Hertzian dipole
			Reflector->ToHertzianDipole(1 * g, 9.47682e18 * e, 0, 0, 0, TVector(0, 0, 1), NULL);
			// make reflective
			Reflector->MakeReflective(reflpara, 0, 1000);
			// set position
			Reflector->SetLinearTrajectory(TVector(0, 0, iz * 1 * m), TVector(0, 0, 0));
			Mirror.push_back(Reflector);
		}

		// create a grid of test charges to represent the field generated by the mirror
		for (int ix = -40; ix <= 0; ix++)
		{
			for (int iz = -10; iz <= 10; iz++)
			{
				TParticle* Probe = scene.Add_Probe(TVector(ix * 0.5 * m, 0, iz * 0.5 * m), TVector(0, 0, 0));
				SecondaryField.push_back(Probe);
				for (std::size_t j = 0; j < Mirror.size(); j++)
				{
					scene.Add_WeberMaxwellForce(Mirror[j], Probe);
				}
			}
		}

		// create electromagnetic forces between transmitter and miror
		for (std::size_t j = 0; j < Mirror.size(); j++)
		{
			scene.Add_WeberMaxwellForce(Mirror[j], Transmitter);
		}

		// simulate the change of the field and the motion of the Hertzian dipole step by step
		for (int i = 0; i * dt <= maxtime; i++)
		{
			// time step
			scene.TimeStep(dt);

			// display simulation
			display.Clear();
			display.PlotForceFieldXZ(PrimaryField, i * dt, 5e4, 10, 10, black);
			display.PlotForceFieldXZ(SecondaryField, i * dt, 5e5, 10, 10, red);
			display.DrawTime(i * dt / ns, "ns", 1, blue);
			display.DrawParticle(Transmitter, i * dt, 5, green);
			display.Draw(true);
		}
	}

	return 0;
}
