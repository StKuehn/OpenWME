/*
Copyright (c) 2023 by Steffen KÃ¼hn, steffen.kuehn@aurinovo.de

This file is part of OpenWME, an electromagnetic field solver based on
Weber-Maxwell electrodynamics.

OpenWME is free software: you can redistribute it and/or modify it under the
terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later version.

OpenWME is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <https://www.gnu.org/licenses/>.
*/

#include <stdio.h>
#include <math.h>
#include "constants.h"
#include "scene.h"
#include "display.h"

const TVector black = TVector(0.25, 0.25, 0.25);
const TVector green = TVector(0, 1, 0);
const TVector red = TVector(1, 0, 0);
const TVector blue = TVector(0, 0, 1);
// the time step of the simulation
const sim_double dt = 0.05 * ns;

// as can be verified, the light clock ticks once per nanosecond, regardless of the speed
// Note: The fixed point iteration does not converge if relative velocities occur which exceed
// the speed of light. Therefore the velocity should not be above 0.9*c, because the
// oscillation in the transmitter has also a velocity
const sim_double speed = 0.9 * c;

sim_double AmplModFunc(sim_double t)
{
	if ((t <= 0.0 * ns) || (t > 0.1 * ns))
	{
		return 0;
	}
	return 1;
}

int main()
{
	TScene scene;
	// fields with virtual test charges to represent the forces as a function of location
	std::deque<TParticle*> PrimaryField;
	std::deque<TParticle*> SecondaryField;

	// create the transmitter
	TParticle* Transmitter = scene.Add_Particle();
	// convert the point charge into a Hertzian dipole
	Transmitter->ToHertzianDipole(mp, e, 1 * nm, 100 * GHz, 0, TVector(1, 0, 0), AmplModFunc);
	// make reflective
	Transmitter->MakeReflective(2e43, 1000);
	// set position
	Transmitter->SetLinearTrajectory(TVector(-70 * cm, 0, 15 * cm), speed * TVector(1, 0, 0));

	// create a grid of test charges to represent the field generated by the transmitter
	for (int ix = -50; ix <= 50; ix++)
	{
		for (int iz = -50; iz <= 50; iz++)
		{
			TParticle* Probe = scene.Add_Probe(TVector(ix * 2 * cm, 0, iz * cm), TVector(0, 0, 0));
			PrimaryField.push_back(Probe);
			scene.Add_WeberMaxwellForce(Transmitter, Probe);
		}
	}

	// the reflector
	TParticle* Reflector = scene.Add_Particle();
	// convert the point charge into a Hertzian dipole
	Reflector->ToHertzianDipole(mp, e, 0, 0, 0, TVector(1, 0, 0), NULL);
	// make reflective
	Reflector->MakeReflective(2e43, 1000);
	// set position
	Reflector->SetLinearTrajectory(TVector(-70 * cm, 0, -15 * cm), speed * TVector(1, 0, 0));

	// create a grid of test charges to represent the field generated by the receiver
	for (int ix = -50; ix <= 50; ix++)
	{
		for (int iz = -50; iz <= 50; iz++)
		{
			TParticle* Probe = scene.Add_Probe(TVector(ix * 2 * cm, 0, iz * cm), TVector(0, 0, 0));
			SecondaryField.push_back(Probe);
			scene.Add_WeberMaxwellForce(Reflector, Probe);
		}
	}

	// create electromagnetic force between transmitter and reflector
	scene.Add_WeberMaxwellForce(Reflector, Transmitter);

	// open a window to display the field and motion of the Hertzian dipole
	TDisplay display(700, 350, -100 * cm, -50 * cm, 100 * cm, 50 * cm, "Moving light clock");

	// simulate the fields and the motion of the particles
	for (int i = 0; ; i++)
	{
		// time step
		scene.TimeStep(dt);

		// display simulation
		display.Clear();
		display.PlotForceFieldXZ(PrimaryField, i * dt, 1e15, 5, 5, black);
		display.PlotForceFieldXZ(SecondaryField, i * dt, 1e15, 5, 5, red);
		display.DrawTime(i * dt / ns, "ns", 1, blue);
		display.DrawParticle(Transmitter, i * dt, 5, green);
		display.DrawParticle(Reflector, i * dt, 5, blue);
		display.Draw(true);
	}

	return 0;
}
